# Lesson 6: Toy Malware Analysis – Analyzing Malicious Code

## Overview

**Malware analysis** is the process of understanding what malicious code does. This lesson covers the basics of analyzing simple malware samples.

Understanding malware analysis helps you:
- Understand how malware works
- Identify malicious behavior
- Extract indicators of compromise (IoCs)
- Develop detection signatures

## What You'll Learn

By the end of this lesson, you will understand:

- **Malware analysis workflow**
- **Static analysis** of malware
- **Dynamic analysis** of malware
- **Identifying malicious behavior**
- **Extracting IoCs** (indicators of compromise)

## Prerequisites

Before starting this lesson, you should:

- Have completed Lessons 1-5 of this course
- Understand reverse engineering basics
- Be comfortable with x64dbg and Binary Ninja

## Malware Analysis Workflow

Malware analysis follows a structured workflow that balances thoroughness with efficiency. The goal is to understand what the malware does, how it works, and how to detect and remove it, all while minimizing the time spent on each sample.

**Triage** is the first step, where you perform a quick initial analysis to determine if the file is actually malware and how dangerous it is. This involves checking file hashes against known malware databases (like VirusTotal), examining basic file properties, and looking for obvious indicators of malicious behavior. Triage helps you prioritize—a ransomware sample gets immediate attention, while adware might be lower priority. This step typically takes 5-15 minutes.

**Static Analysis** involves examining the binary without executing it. You analyze the PE structure, imports, exports, strings, and code to understand what the malware might do. Static analysis is safe (the malware never runs) and can reveal a lot of information, but it's limited by obfuscation and packing. If the malware is heavily packed or encrypted, static analysis might not reveal much. This step can take anywhere from 30 minutes to several hours depending on complexity.

**Dynamic Analysis** involves running the malware in a controlled sandbox environment and observing its behavior. You monitor system calls, network traffic, file operations, registry modifications, and process creation to see what the malware actually does. Dynamic analysis reveals the malware's true behavior, bypassing obfuscation, but it requires careful sandboxing to prevent the malware from escaping or detecting the analysis environment. This step typically takes 1-3 hours.

**IoC Extraction** involves collecting indicators of compromise—artifacts that can be used to detect the malware on other systems. This includes file hashes, file paths, registry keys, network indicators (URLs, IPs, domains), and behavioral patterns. These IoCs are shared with the security community and used to update detection tools. This step takes 15-30 minutes.

**Report** is the final step where you document your findings in a clear, structured format. The report should include an executive summary, technical details, IoCs, and recommendations for detection and remediation. Good documentation is crucial because other analysts will use your report to understand the malware and respond to infections. This step takes 30 minutes to 2 hours depending on the depth required.

## Static Analysis of Malware

Static analysis is your first deep dive into the malware, examining it without executing it. This approach is safe and can reveal significant information about the malware's capabilities and intent.

### Steps

The static analysis process follows a systematic approach to extract maximum information from the binary.

**Check the file type** to confirm it's actually a PE executable and not a script, document, or other file type. Use the `file` command on Linux or examine the file headers in a hex editor. Look for the "MZ" signature at the beginning and the "PE" signature at offset 0x3C. Check if it's x86 or x64, and whether it's an EXE or DLL. Some malware disguises itself with double extensions (like "document.pdf.exe") or uses misleading icons, so don't trust the file extension alone.

**Check for packing** because packed malware hides its true code and strings. Use tools like Detect It Easy (DIE) or PEiD to identify common packers like UPX, ASPack, or Themida. Check the entropy of sections—high entropy (close to 8.0) indicates encryption or compression. Look at the import table—if a binary has very few imports (like just `LoadLibrary` and `GetProcAddress`), it's likely packed and will resolve imports dynamically. If it's packed, you'll need to unpack it before meaningful static analysis is possible.

**Analyze imports** to see what Windows APIs the malware uses. Imports reveal capabilities: `CreateRemoteThread` and `VirtualAllocEx` suggest process injection, `RegSetValueEx` suggests registry modification for persistence, `InternetOpenA` and `HttpSendRequestA` suggest network communication, and `CryptEncrypt` suggests encryption (possibly ransomware). Use tools like PE-bear or Binary Ninja to view the import table. Note that sophisticated malware resolves imports dynamically to hide its capabilities, so a sparse import table might indicate evasion.

**Analyze strings** to find URLs, IP addresses, file paths, registry keys, and other interesting data. Use the `strings` command or a tool like FLOSS (FireEye Labs Obfuscated String Solver) which can extract obfuscated strings. Look for C2 (command and control) server addresses, file paths where the malware might drop files, registry keys for persistence, and error messages that reveal functionality. Strings often provide the quickest insight into what the malware does.

**Analyze code** by opening the binary in Binary Ninja, Ghidra, or IDA Pro. Start with the entry point and trace through the execution flow. Look for the main malicious functionality—is it downloading additional payloads? Stealing credentials? Encrypting files? Identify key functions and understand their purpose. This is the most time-consuming part of static analysis but provides the deepest understanding.

### Red Flags

Certain imports and strings are strong indicators of malicious behavior and should immediately raise suspicion.

**Imports for process injection** like `CreateRemoteThread`, `VirtualAllocEx`, `WriteProcessMemory`, and `NtCreateThreadEx` indicate the malware injects code into other processes. This is a common technique to hide malicious activity, evade detection, and gain elevated privileges. Legitimate software rarely uses these APIs, so their presence is a major red flag.

**Imports for registry modification** like `RegSetValueEx`, `RegCreateKeyEx`, and `RegOpenKeyEx` suggest the malware modifies the registry, often for persistence (adding itself to startup locations) or configuration. Check which registry keys are being modified—keys like `HKLM\Software\Microsoft\Windows\CurrentVersion\Run` are used for persistence.

**Imports for file operations** like `CreateFileA`, `WriteFile`, `DeleteFileA`, and `MoveFileEx` indicate file manipulation. Malware might drop additional files, delete logs, or encrypt user files (ransomware). The presence of these APIs isn't inherently malicious (legitimate programs use them too), but combined with other indicators, they suggest malicious intent.

**Suspicious strings** are often the smoking gun. URLs and IP addresses (especially to suspicious domains or IPs in foreign countries) suggest C2 communication. Registry keys like `HKLM\...\Run` suggest persistence. File paths in `%TEMP%` or `%APPDATA%` suggest the malware drops files. Strings like "encrypt", "ransom", "bitcoin", or "password" reveal the malware's purpose.

## Dynamic Analysis of Malware

Dynamic analysis involves actually running the malware in a controlled environment and observing what it does. This reveals the malware's true behavior, bypassing obfuscation and packing.

### Steps

Dynamic analysis requires careful setup to ensure the malware can't escape the sandbox or cause real damage.

**Set up a sandbox** using a virtual machine that's completely isolated from your network and production systems. Use VMware or VirtualBox with a clean Windows installation. Take a snapshot before running the malware so you can easily revert. Disable network access or use a fake network (like INetSim) to simulate internet connectivity without actually connecting to the internet. Never run malware on your host system or on a VM that has access to your network.

**Monitor system calls** using Process Monitor (ProcMon) to see every file, registry, and process operation the malware performs. Start ProcMon before running the malware, then filter the results to show only the malware's process. Look for file creation (dropped files), registry modifications (persistence), and process creation (spawning child processes). ProcMon provides a detailed timeline of the malware's actions.

**Monitor network traffic** using Wireshark to capture all network packets. Start Wireshark before running the malware, then analyze the captured traffic. Look for DNS queries (what domains is it contacting?), HTTP/HTTPS requests (what URLs?), and raw TCP/UDP connections (what IPs and ports?). This reveals C2 servers and data exfiltration. If the malware uses encryption, you might only see encrypted traffic, but you can still identify the C2 server addresses.

**Monitor file operations** by watching for new files created, existing files modified, or files deleted. Check common malware locations like `%TEMP%`, `%APPDATA%`, and `C:\Windows\System32`. Use tools like Process Monitor or manually check these directories before and after running the malware. Malware often drops additional payloads, configuration files, or encrypted copies of user files.

**Monitor registry operations** by watching for registry keys created or modified. Use Process Monitor or Regshot (which takes before/after snapshots of the registry). Look for persistence mechanisms in `Run` keys, service creation in `HKLM\System\CurrentControlSet\Services`, and configuration data in `HKLM\Software` or `HKCU\Software`.

### Tools

Several specialized tools make dynamic analysis more effective and efficient.

**ProcMon** (Process Monitor) is essential for monitoring system calls. It shows every file, registry, and process operation in real-time with filtering capabilities. You can filter by process name, operation type, or path to focus on relevant activity. ProcMon's timeline view helps you understand the sequence of malware actions.

**Wireshark** is the standard tool for network traffic analysis. It captures all packets and provides powerful filtering and analysis features. You can follow TCP streams to see full conversations, extract files transferred over HTTP, and identify protocols used. Wireshark helps you find C2 servers and understand network-based malware behavior.

**Process Explorer** shows all running processes, their relationships (parent-child), loaded DLLs, open handles, and resource usage. It's more powerful than Task Manager and helps you identify malware processes, see what DLLs they've loaded (including injected DLLs), and understand process relationships. Process Explorer can also verify digital signatures and check processes against VirusTotal.

**Autoruns** shows all programs configured to run at startup, including registry Run keys, scheduled tasks, services, and browser helper objects. Malware often achieves persistence through these mechanisms, and Autoruns makes it easy to identify suspicious startup entries. You can disable entries directly from Autoruns to prevent malware from restarting.

## Extracting IoCs

**Indicators of Compromise (IoCs)** are artifacts left by malware that can be used to detect infections on other systems. Extracting and sharing IoCs is crucial for the security community to respond to malware campaigns.

### Types of IoCs

Different types of IoCs serve different detection purposes and have different levels of reliability.

**File hashes** (MD5, SHA1, SHA256) uniquely identify malware files. If you find a file with a known malware hash, you know it's malicious. However, hashes are fragile—changing a single byte changes the hash, so malware authors often create polymorphic variants with different hashes. SHA256 is preferred over MD5 and SHA1 due to collision resistance. Always include all three hash types for compatibility with different tools.

**File paths** indicate where malware drops files or looks for configuration. Paths like `C:\Users\Public\svchost.exe` or `%APPDATA%\Microsoft\Windows\update.exe` are suspicious because they're in unusual locations or use misleading names. File path IoCs help you search systems for malware artifacts, but they're less reliable than hashes because malware can easily change where it drops files.

**Registry keys** show where malware achieves persistence or stores configuration. Keys like `HKLM\Software\Microsoft\Windows\CurrentVersion\Run\WindowsUpdate` (note the misleading name) indicate persistence mechanisms. Registry IoCs help you detect and remove malware persistence, ensuring it doesn't restart after reboot.

**Network indicators** include URLs, IP addresses, and domain names used for C2 communication or payload downloads. These are extremely valuable because they can be blocked at the network level, preventing malware from communicating even if it's already on a system. However, network IoCs have limited lifespan—malware authors can change C2 servers quickly. Domain-based IoCs are more durable than IP-based ones if the malware uses domain generation algorithms (DGAs).

**Process names** identify malware processes, though this is a weak IoC because process names are easily changed. Still, knowing that malware runs as `svchost.exe` from `%TEMP%` (instead of the legitimate `svchost.exe` from `System32`) helps identify infections. Combine process names with other IoCs like file paths and hashes for reliable detection.

## Exercises

### Exercise 1: Analyze a Simple Malware Sample

**Objective**: Learn to analyze malware.

**Steps**:
1. Download a simple malware sample (or create a toy malware)
2. Perform static analysis:
   - Check the file type
   - Check for packing
   - Analyze imports
   - Analyze strings
3. Document your findings

**Verification**: You should be able to identify malicious characteristics.

### Exercise 2: Dynamic Analysis of Malware

**Objective**: Learn to perform dynamic analysis.

**Steps**:
1. Set up a virtual machine sandbox
2. Run the malware sample
3. Monitor system calls using ProcMon
4. Monitor network traffic using Wireshark
5. Document the malware's behavior

**Verification**: You should be able to identify malicious behavior.

### Exercise 3: Extract IoCs

**Objective**: Learn to extract indicators of compromise.

**Steps**:
1. Analyze a malware sample
2. Extract:
   - File hashes
   - File paths
   - Registry keys
   - Network indicators
   - Process names
3. Document your findings

**Verification**: You should be able to extract IoCs.

## Solutions

### Solution 1: Analyze a Simple Malware Sample

Here's a complete walkthrough of analyzing a toy malware sample. For educational purposes, we'll create a simple "malware" that demonstrates common malicious behaviors without actually being harmful.

**Creating a Toy Malware (for analysis practice):**

```rust
// toy_malware.rs - Educational malware sample for analysis practice
use std::fs::File;
use std::io::Write;
use std::process::Command;

fn main() {
    // Behavior 1: Create a file in TEMP directory
    create_persistence_file();

    // Behavior 2: Attempt to modify registry (will fail without admin)
    modify_registry();

    // Behavior 3: Simulate C2 communication (doesn't actually connect)
    simulate_c2();
}

fn create_persistence_file() {
    let temp_dir = std::env::temp_dir();
    let file_path = temp_dir.join("system_update.exe");

    if let Ok(mut file) = File::create(&file_path) {
        let _ = file.write_all(b"Malware payload");
        println!("[+] Created file: {:?}", file_path);
    }
}

fn modify_registry() {
    // Attempt to add to Run key (will fail without admin)
    let _ = Command::new("reg")
        .args(&["add", "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
                "/v", "SystemUpdate", "/t", "REG_SZ", "/d", "C:\\Temp\\system_update.exe"])
        .output();
    println!("[+] Attempted registry modification");
}

fn simulate_c2() {
    // Simulate C2 communication (doesn't actually connect)
    println!("[+] Simulating C2 to 192.168.1.100:8080");
}
```

Compile with: `rustc toy_malware.rs`

**Static Analysis:**

1. **Check file type:** Use `file toy_malware.exe` - confirms it's a PE executable
2. **Check for packing:** Use Detect It Easy - shows it's not packed (Rust binaries are typically not packed)
3. **Analyze imports:** Open in PE-bear or Binary Ninja:
   - `CreateFileW` - file creation
   - `WriteFile` - file writing
   - `CreateProcessW` - process creation (for running `reg.exe`)
   - These imports suggest file manipulation and process creation
4. **Analyze strings:** Use `strings toy_malware.exe`:
   - `system_update.exe` - suspicious filename
   - `HKCU\Software\Microsoft\Windows\CurrentVersion\Run` - persistence registry key
   - `192.168.1.100:8080` - C2 server address
   - These strings immediately reveal the malware's intent

**Analysis Report:**

```
=== Static Analysis Report ===

File: toy_malware.exe
MD5: [hash]
SHA256: [hash]

Architecture: x64
Packing: None detected

Suspicious Imports:
- CreateFileW (file creation)
- WriteFile (file writing)
- CreateProcessW (process creation)

Suspicious Strings:
- "system_update.exe" - dropped file name
- "HKCU\...\Run" - persistence mechanism
- "192.168.1.100:8080" - potential C2 server

Assessment: This binary exhibits multiple indicators of malicious behavior:
1. Creates files in TEMP directory with misleading names
2. Attempts to establish persistence via registry Run key
3. Contains hardcoded C2 server address

Recommendation: Quarantine and perform dynamic analysis in isolated environment.
```

### Solution 2: Dynamic Analysis of Malware

Here's a complete walkthrough of performing dynamic analysis on the toy malware sample.

**Setup:**
1. Create a Windows VM (Windows 10 recommended)
2. Take a snapshot named "Clean State"
3. Install analysis tools: ProcMon, Wireshark, Process Explorer
4. Disable network or use INetSim for fake network

**Dynamic Analysis Steps:**

1. **Start monitoring tools:**
   - Launch ProcMon with filters: `Process Name is toy_malware.exe`
   - Launch Wireshark on all interfaces
   - Launch Process Explorer

2. **Execute the malware:**
   - Run `toy_malware.exe`
   - Observe the console output

3. **Analyze ProcMon results:**
   ```
   Time        Operation       Path                                    Result
   10:30:01    CreateFile      C:\Users\...\Temp\system_update.exe    SUCCESS
   10:30:01    WriteFile       C:\Users\...\Temp\system_update.exe    SUCCESS
   10:30:02    CreateProcess   C:\Windows\System32\reg.exe            SUCCESS
   10:30:02    RegSetValue     HKCU\...\Run\SystemUpdate              ACCESS DENIED
   ```

   **Observations:**
   - File created in TEMP directory
   - Registry modification attempted (failed due to permissions)
   - Spawned `reg.exe` process

4. **Analyze Wireshark results:**
   - No actual network traffic (the malware only prints a message)
   - In real malware, you'd see DNS queries, TCP connections, HTTP requests

5. **Check file system:**
   - Navigate to `%TEMP%` directory
   - Find `system_update.exe` file
   - Calculate hash: `certutil -hashfile system_update.exe SHA256`

6. **Check registry:**
   - Open Registry Editor
   - Navigate to `HKCU\Software\Microsoft\Windows\CurrentVersion\Run`
   - Check if `SystemUpdate` entry was created (it won't be due to access denied)

**Dynamic Analysis Report:**

```
=== Dynamic Analysis Report ===

Execution Time: 2024-01-15 10:30:00
Duration: 2 seconds

File Operations:
- Created: C:\Users\Analyst\AppData\Local\Temp\system_update.exe (15 bytes)

Registry Operations:
- Attempted: HKCU\Software\Microsoft\Windows\CurrentVersion\Run\SystemUpdate
- Result: ACCESS DENIED

Process Operations:
- Spawned: reg.exe (to modify registry)

Network Operations:
- None observed (only console output mentioning 192.168.1.100:8080)

Behavior Summary:
1. Drops file in TEMP directory with misleading name
2. Attempts persistence via Run key (failed)
3. Simulates C2 communication (no actual network traffic)

Threat Level: Low (educational sample, limited functionality)
```

### Solution 3: Extract IoCs

Here's a complete example of extracting and documenting Indicators of Compromise (IoCs) from the malware analysis.

**IoC Extraction Process:**

1. **File Hashes:**
   ```
   MD5:    a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
   SHA1:   1234567890abcdef1234567890abcdef12345678
   SHA256: abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890
   ```

   Use these hashes to search VirusTotal and other malware databases.

2. **File Paths:**
   ```
   C:\Users\[Username]\AppData\Local\Temp\system_update.exe
   ```

   Search for this file on other systems to detect infections.

3. **Registry Keys:**
   ```
   HKCU\Software\Microsoft\Windows\CurrentVersion\Run\SystemUpdate
   Value: C:\Temp\system_update.exe
   ```

   Check this registry key on other systems for persistence.

4. **Network Indicators:**
   ```
   IP Address: 192.168.1.100
   Port: 8080
   Protocol: Unknown (simulated)
   ```

   Block this IP at the firewall level.

5. **Process Names:**
   ```
   toy_malware.exe
   system_update.exe (dropped file)
   reg.exe (spawned process)
   ```

**IoC Report (STIX/OpenIOC format):**

```json
{
  "ioc_report": {
    "malware_name": "ToyMalware.Educational",
    "analysis_date": "2024-01-15",
    "analyst": "Security Researcher",
    "file_indicators": {
      "md5": "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6",
      "sha256": "abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
      "file_paths": [
        "C:\\Users\\*\\AppData\\Local\\Temp\\system_update.exe"
      ]
    },
    "registry_indicators": [
      {
        "key": "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
        "value_name": "SystemUpdate",
        "value_data": "C:\\Temp\\system_update.exe"
      }
    ],
    "network_indicators": [
      {
        "ip": "192.168.1.100",
        "port": 8080,
        "protocol": "TCP"
      }
    ],
    "behavioral_indicators": [
      "Creates files in TEMP directory",
      "Modifies Run registry key for persistence",
      "Spawns reg.exe process"
    ]
  }
}
```

**Using IoCs for Detection:**

1. **YARA Rule:**
   ```yara
   rule ToyMalware_Educational {
       meta:
           description = "Detects ToyMalware educational sample"
           author = "Security Researcher"
           date = "2024-01-15"

       strings:
           $s1 = "system_update.exe" ascii
           $s2 = "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" ascii
           $s3 = "192.168.1.100:8080" ascii

       condition:
           2 of ($s*)
   }
   ```

2. **Firewall Rule:**
   ```
   Block outbound connections to 192.168.1.100:8080
   ```

3. **File System Scan:**
   ```powershell
   Get-ChildItem -Path "C:\Users\*\AppData\Local\Temp" -Filter "system_update.exe" -Recurse
   ```

4. **Registry Scan:**
   ```powershell
   Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" | Where-Object { $_.SystemUpdate }
   ```

These IoCs can be shared with the security community, integrated into SIEM systems, and used to detect and respond to infections across your organization.

## Summary

You now understand malware analysis. You can:

- Perform static analysis of malware
- Perform dynamic analysis of malware
- Identify malicious behavior
- Extract indicators of compromise
- Document malware analysis findings

In the next lesson, you'll learn about automation with Python.
