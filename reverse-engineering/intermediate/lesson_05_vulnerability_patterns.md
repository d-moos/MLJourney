# Lesson 5: Vulnerability Patterns – Recognizing Common Security Flaws

## Overview

When reverse engineering binaries, you often encounter common vulnerability patterns. Understanding these patterns helps you:
- Identify security flaws
- Understand how exploits work
- Recognize dangerous code patterns
- Develop secure code

## What You'll Learn

By the end of this lesson, you will understand:

- **Buffer overflows** and how to recognize them
- **Format string vulnerabilities**
- **Use-after-free bugs**
- **Integer overflows**
- **Race conditions**
- **How to identify these vulnerabilities** in disassembly

## Prerequisites

Before starting this lesson, you should:

- Have completed Lessons 1-4 of this course
- Understand x86-64 assembly
- Be comfortable with memory management

## Buffer Overflows

A **buffer overflow** occurs when data is written beyond the bounds of a buffer.

### Example: Vulnerable Code

```c
void vulnerable_function(char* input) {
    char buffer[64];
    strcpy(buffer, input);  // No bounds checking!
}
```

### Recognizing Buffer Overflows in Disassembly

When you're reverse engineering a binary and looking for buffer overflows, certain patterns in the disassembly immediately raise red flags.

The most obvious indicator is a `mov` instruction (or series of `mov` instructions) that writes to a stack buffer without any preceding bounds check. You'll see the code calculating a stack address (like `lea rax, [rbp-0x40]` to get the address of a 64-byte buffer), then writing to it in a loop or with a function call. If there's no comparison instruction (`cmp`) checking the size before the write, it's potentially vulnerable.

Calls to unsafe string functions are major red flags. Functions like `strcpy`, `sprintf`, `gets`, `scanf` with `%s`, and `strcat` don't perform bounds checking—they just keep copying until they hit a null terminator. When you see `call strcpy` in disassembly, immediately check what's being copied and where. If the source is user-controlled (from a file, network, or command-line argument) and the destination is a fixed-size stack buffer, you've likely found a buffer overflow.

Look for the absence of safe alternatives. Modern code should use `strncpy`, `snprintf`, `fgets`, or better yet, safe string libraries. If you see the old unsafe functions, especially in code that handles user input, it's a strong indicator of potential vulnerabilities.

### Exploiting Buffer Overflows

Buffer overflows are powerful vulnerabilities that can be exploited in several ways, depending on what you can overwrite and what protections are in place.

**Overwrite the return address** is the classic buffer overflow exploit. When a function returns, it pops the return address from the stack and jumps to it. If you can overflow a stack buffer, you can overwrite the return address with an address of your choosing. When the function returns, execution jumps to your address instead of the legitimate caller. This allows you to redirect execution to shellcode you've injected, to a ROP chain, or to existing code in the binary (like a "win" function in a CTF challenge).

**Execute arbitrary code** by injecting shellcode into the buffer and redirecting execution to it. In the simplest case (no DEP/NX), you overflow the buffer with your shellcode, overwrite the return address to point back to the buffer, and when the function returns, your shellcode executes. Modern systems have DEP (Data Execution Prevention) which marks the stack as non-executable, but you can bypass this with ROP (Return-Oriented Programming) or by using existing executable memory.

**Bypass security checks** by overwriting variables that control access. If a stack buffer is adjacent to a variable like `is_admin` or `password_correct`, you can overflow the buffer to overwrite that variable. For example, if `is_admin` is 0 (false) and sits right after your buffer, you can overflow the buffer with enough data to reach and overwrite `is_admin` with 1 (true), bypassing the authentication check.

## Format String Vulnerabilities

A **format string vulnerability** occurs when user-controlled input is used as the format string argument to functions like `printf`, `sprintf`, or `fprintf`. This is dangerous because format strings have special directives (like `%x`, `%s`, `%n`) that can read from or write to memory, and an attacker can craft a malicious format string to exploit this.

### Example: Vulnerable Code

```c
void vulnerable_function(char* input) {
    printf(input);  // User input as format string!
}
```

This looks innocent, but it's extremely dangerous. If `input` is `"Hello"`, it just prints "Hello". But if `input` is `"%x %x %x %x"`, it reads four values from the stack and prints them in hexadecimal, leaking memory contents. If `input` is `"%s"`, it tries to dereference a stack value as a string pointer, potentially crashing the program or leaking data. If `input` is `"%n"`, it writes to memory, allowing arbitrary memory writes.

The correct code is `printf("%s", input)`, which treats `input` as data, not as a format string.

### Recognizing Format String Vulnerabilities

In disassembly, format string vulnerabilities have a distinctive pattern that's easy to spot once you know what to look for.

Look for user input passed directly to `printf`, `sprintf`, `fprintf`, or similar functions. In x64 Windows calling convention, the first argument (the format string) is in RCX. If you see code that loads a user-controlled buffer into RCX and then calls `printf`, that's a format string vulnerability. For example:
```asm
lea rcx, [rbp-0x100]    ; Load user input buffer
call printf              ; Vulnerable!
```

The safe version would have two arguments:
```asm
lea rdx, [rbp-0x100]    ; Load user input buffer (second argument)
lea rcx, format_string  ; Load "%s" (first argument)
call printf              ; Safe
```

Watch for the absence of validation. Safe code either uses a hardcoded format string or validates the format string before use. If there's no validation and the format string comes from user input, it's vulnerable.

### Exploiting Format String Vulnerabilities

Format string vulnerabilities are incredibly versatile and can be exploited for various purposes.

**Read memory** using format specifiers like `%x` (read hex value from stack) or `%s` (read string from address on stack). By carefully crafting the format string, you can read arbitrary memory locations. For example, `"%7$x"` reads the 7th argument from the stack. You can use this to leak addresses (defeating ASLR), read sensitive data, or gather information about the program's memory layout.

**Write memory** using the `%n` format specifier, which writes the number of bytes printed so far to the address pointed to by the corresponding argument. This is extremely powerful—you can write arbitrary values to arbitrary addresses. For example, you can overwrite a return address, overwrite a function pointer, or modify a variable that controls access. The technique involves carefully controlling how many bytes are printed (using width specifiers like `%100x`) to write the desired value.

**Execute arbitrary code** by combining memory reads and writes. First, leak addresses to defeat ASLR. Then, use `%n` to overwrite a function pointer or return address with the address of your shellcode or a ROP chain. When the overwritten pointer is used, execution redirects to your code.

## Use-After-Free Bugs

A **use-after-free bug** occurs when a program continues to use a pointer after the memory it points to has been freed. This is a temporal memory safety violation—the pointer is valid at one point in time but becomes invalid after the `free` call. Use-after-free bugs are particularly dangerous because the freed memory might be reallocated for a different purpose, leading to type confusion and exploitable conditions.

### Example: Vulnerable Code

```c
void vulnerable_function() {
    int* ptr = malloc(sizeof(int));
    free(ptr);
    *ptr = 5;  // Use-after-free!
}
```

After `free(ptr)`, the memory is returned to the heap allocator and might be reused for another allocation. Writing to `*ptr` after the free is undefined behavior—it might crash, might corrupt other data, or might appear to work (if the memory hasn't been reused yet). An attacker can exploit this by controlling what gets allocated in the freed memory, leading to type confusion or control flow hijacking.

### Recognizing Use-After-Free Bugs

Identifying use-after-free bugs in disassembly requires tracking pointer lifetimes and looking for uses after frees.

Look for a `free` call (or `delete` in C++) followed by continued use of the freed pointer. In disassembly, you'll see `call free` with the pointer in RCX (on x64 Windows), and then later you'll see that same pointer being dereferenced (like `mov [rax], 5` where RAX contains the freed pointer). The key is recognizing that the pointer hasn't been set to NULL after the free.

Watch for the absence of null checks. Safe code sets pointers to NULL after freeing them (`ptr = NULL;`) and checks for NULL before dereferencing. If you see a `free` call without a subsequent `mov [ptr], 0` (setting to NULL), and later dereferences without `test rax, rax` or `cmp rax, 0` (null check), it's potentially vulnerable.

Look for complex control flow where a pointer might be freed in one path and used in another. This is harder to spot but common in real-world code. You need to trace all possible execution paths to see if there's a path where the pointer is freed and then used.

## Integer Overflows

An **integer overflow** occurs when an arithmetic operation produces a result that exceeds the maximum value that can be stored in the integer type. For example, if you add 1 to the maximum value of an unsigned 32-bit integer (0xFFFFFFFF), it wraps around to 0. This can lead to security vulnerabilities when the overflowed value is used for memory allocation sizes, buffer sizes, or loop bounds.

### Example: Vulnerable Code

```c
void vulnerable_function(int size) {
    int buffer_size = size + 1;  // Integer overflow!
    char* buffer = malloc(buffer_size);
}
```

If `size` is 0xFFFFFFFF (the maximum value for a signed 32-bit integer when interpreted as unsigned), then `size + 1` wraps around to 0. The code then allocates a 0-byte buffer, but later code might assume the buffer is `size + 1` bytes large and write beyond the allocated size, causing a heap overflow.

### Recognizing Integer Overflows

Spotting integer overflows in disassembly requires understanding arithmetic operations and looking for missing overflow checks.

Look for `add` or `mul` instructions that operate on user-controlled values without subsequent overflow checks. In x86/x64, arithmetic operations set the overflow flag (OF) and carry flag (CF) when overflow occurs. Safe code checks these flags using conditional jumps like `jo` (jump if overflow) or `jc` (jump if carry). If you see `add eax, ebx` followed immediately by using EAX without checking OF or CF, it's potentially vulnerable.

Watch for size calculations before memory allocations. Code like `malloc(size * count)` is vulnerable if `size * count` can overflow. For example, if `size` is 0x80000000 and `count` is 2, the multiplication overflows to 0, allocating a 0-byte buffer. Look for `imul` or `mul` instructions followed by `call malloc` without overflow checks in between.

Check for missing validation of user input. Safe code validates that arithmetic operations won't overflow before performing them. For example, before computing `a + b`, check that `a <= MAX_INT - b`. If there's no such validation and the operands come from user input, it's vulnerable.
- The result is used as a size for memory allocation

## Exercises

### Exercise 1: Identify Buffer Overflow Vulnerabilities

**Objective**: Learn to recognize buffer overflows.

**Steps**:
1. Write a vulnerable C program with a buffer overflow
2. Compile it
3. Open it in Binary Ninja
4. Identify the buffer overflow vulnerability
5. Document your findings

**Verification**: You should be able to identify the buffer overflow.

### Exercise 2: Identify Format String Vulnerabilities

**Objective**: Learn to recognize format string vulnerabilities.

**Steps**:
1. Write a vulnerable C program with a format string vulnerability
2. Compile it
3. Open it in Binary Ninja
4. Identify the format string vulnerability
5. Document your findings

**Verification**: You should be able to identify the format string vulnerability.

### Exercise 3: Identify Use-After-Free Bugs

**Objective**: Learn to recognize use-after-free bugs.

**Steps**:
1. Write a vulnerable C program with a use-after-free bug
2. Compile it
3. Open it in Binary Ninja
4. Identify the use-after-free bug
5. Document your findings

**Verification**: You should be able to identify the use-after-free bug.

## Solutions

### Solution 1: Identify Buffer Overflow Vulnerabilities

Here's a complete example of creating and analyzing a buffer overflow vulnerability:

**Vulnerable C Program:**
```c
#include <stdio.h>
#include <string.h>

void vulnerable_function(char* input) {
    char buffer[64];
    strcpy(buffer, input);  // No bounds checking!
    printf("You entered: %s\n", buffer);
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }

    vulnerable_function(argv[1]);
    return 0;
}
```

Compile with: `gcc -o buffer_overflow buffer_overflow.c -fno-stack-protector -z execstack`

**Analysis in Binary Ninja:**

When you open this in Binary Ninja and navigate to `vulnerable_function`, you'll see assembly like:

```asm
sub rsp, 0x50          ; Allocate 80 bytes on stack (64 for buffer + 16 for alignment)
lea rax, [rbp-0x40]    ; Load address of buffer (64 bytes from RBP)
mov rdi, rax           ; First argument (destination)
mov rsi, rcx           ; Second argument (source - user input)
call strcpy            ; Call strcpy with no bounds checking
```

**Key indicators of the vulnerability:**
1. The buffer is allocated on the stack (`sub rsp, 0x50`)
2. The call to `strcpy` has no preceding bounds check (no `cmp` or `strlen` call)
3. The source is user-controlled (from `argv[1]`)
4. If the input is longer than 64 bytes, it will overflow the buffer and overwrite the return address

**Exploitation:** If you run `./buffer_overflow $(python -c 'print "A"*80')`, you'll overflow the buffer and likely crash the program. With careful crafting, you could overwrite the return address to redirect execution.

### Solution 2: Identify Format String Vulnerabilities

Here's a complete example of creating and analyzing a format string vulnerability:

**Vulnerable C Program:**
```c
#include <stdio.h>

void vulnerable_function(char* input) {
    printf(input);  // User input as format string!
    printf("\n");
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }

    vulnerable_function(argv[1]);
    return 0;
}
```

Compile with: `gcc -o format_string format_string.c`

**Analysis in Binary Ninja:**

When you open this in Binary Ninja and navigate to `vulnerable_function`, you'll see assembly like:

```asm
mov rdi, rcx           ; Load user input into RDI (first argument)
call printf            ; Call printf with user input as format string
```

**Key indicators of the vulnerability:**
1. User input is passed directly to `printf` as the first (and only) argument
2. There's no hardcoded format string like `"%s"`
3. The safe version would be: `lea rdi, format_str; mov rsi, input; call printf` where `format_str` is `"%s"`

**Exploitation:**
- Run `./format_string "AAAA %x %x %x %x"` to leak stack values
- Run `./format_string "%s"` to potentially crash by dereferencing a stack value as a string pointer
- Run `./format_string "%n"` to write to memory (advanced exploitation)

### Solution 3: Identify Use-After-Free Bugs

Here's a complete example of creating and analyzing a use-after-free vulnerability:

**Vulnerable C Program:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct User {
    char name[32];
    int id;
};

void vulnerable_function() {
    struct User* user = malloc(sizeof(struct User));
    strcpy(user->name, "Alice");
    user->id = 1;

    printf("User: %s (ID: %d)\n", user->name, user->id);

    free(user);  // Free the memory

    // Use-after-free: accessing freed memory
    printf("User ID after free: %d\n", user->id);  // Dangerous!

    // Even more dangerous: writing to freed memory
    user->id = 2;  // This might corrupt other allocations
}

int main() {
    vulnerable_function();
    return 0;
}
```

Compile with: `gcc -o use_after_free use_after_free.c`

**Analysis in Binary Ninja:**

When you open this in Binary Ninja and navigate to `vulnerable_function`, you'll see assembly like:

```asm
call malloc            ; Allocate memory
mov [rbp-0x8], rax     ; Store pointer in local variable

; ... use the memory ...

mov rdi, [rbp-0x8]     ; Load pointer
call free              ; Free the memory

; Use-after-free:
mov rax, [rbp-0x8]     ; Load the SAME pointer (not set to NULL!)
mov eax, [rax+0x20]    ; Dereference freed pointer to read id field
```

**Key indicators of the vulnerability:**
1. A `call free` with a pointer
2. The pointer is NOT set to NULL after the free (no `mov [rbp-0x8], 0`)
3. The same pointer is dereferenced later (loaded from `[rbp-0x8]` and used)
4. No null check before the dereference (no `test rax, rax` or `cmp rax, 0`)

**Why it's dangerous:** After `free(user)`, the memory might be reused for another allocation. If you write to `user->id`, you might be corrupting data in a completely different object, leading to crashes or exploitable conditions. An attacker can control what gets allocated in the freed memory, leading to type confusion vulnerabilities.

**Safe version:** After `free(user)`, set `user = NULL`, and check for NULL before dereferencing: `if (user != NULL) { ... }`

## Summary

You now understand common vulnerability patterns. You can:

- Recognize buffer overflows
- Recognize format string vulnerabilities
- Recognize use-after-free bugs
- Recognize integer overflows
- Identify these vulnerabilities in disassembly

In the next lesson, you'll learn about malware analysis.
