# Lesson 5: Vulnerability Patterns â€“ Recognizing Common Security Flaws

## Overview

When reverse engineering binaries, you often encounter common vulnerability patterns. Understanding these patterns helps you:
- Identify security flaws
- Understand how exploits work
- Recognize dangerous code patterns
- Develop secure code

## What You'll Learn

By the end of this lesson, you will understand:

- **Buffer overflows** and how to recognize them
- **Format string vulnerabilities**
- **Use-after-free bugs**
- **Integer overflows**
- **Race conditions**
- **How to identify these vulnerabilities** in disassembly

## Prerequisites

Before starting this lesson, you should:

- Have completed Lessons 1-4 of this course
- Understand x86-64 assembly
- Be comfortable with memory management

## Buffer Overflows

A **buffer overflow** occurs when data is written beyond the bounds of a buffer.

### Example: Vulnerable Code

```c
void vulnerable_function(char* input) {
    char buffer[64];
    strcpy(buffer, input);  // No bounds checking!
}
```

### Recognizing Buffer Overflows in Disassembly

In disassembly, buffer overflows look like:
- A `mov` instruction that writes to a stack buffer
- No bounds checking before the write
- A `call` to `strcpy`, `sprintf`, or similar unsafe functions

### Exploiting Buffer Overflows

Buffer overflows can be exploited to:
- Overwrite the return address
- Execute arbitrary code
- Bypass security checks

## Format String Vulnerabilities

A **format string vulnerability** occurs when user input is used as a format string.

### Example: Vulnerable Code

```c
void vulnerable_function(char* input) {
    printf(input);  // User input as format string!
}
```

### Recognizing Format String Vulnerabilities

In disassembly, format string vulnerabilities look like:
- User input passed directly to `printf`, `sprintf`, or similar functions
- No validation of the format string

### Exploiting Format String Vulnerabilities

Format string vulnerabilities can be exploited to:
- Read memory
- Write memory
- Execute arbitrary code

## Use-After-Free Bugs

A **use-after-free bug** occurs when memory is used after it's been freed.

### Example: Vulnerable Code

```c
void vulnerable_function() {
    int* ptr = malloc(sizeof(int));
    free(ptr);
    *ptr = 5;  // Use-after-free!
}
```

### Recognizing Use-After-Free Bugs

In disassembly, use-after-free bugs look like:
- A `free` call
- Followed by a dereference of the freed pointer
- No null check

## Integer Overflows

An **integer overflow** occurs when an integer exceeds its maximum value.

### Example: Vulnerable Code

```c
void vulnerable_function(int size) {
    int buffer_size = size + 1;  // Integer overflow!
    char* buffer = malloc(buffer_size);
}
```

### Recognizing Integer Overflows

In disassembly, integer overflows look like:
- An `add` or `mul` instruction
- No overflow check
- The result is used as a size for memory allocation

## Exercises

### Exercise 1: Identify Buffer Overflow Vulnerabilities

**Objective**: Learn to recognize buffer overflows.

**Steps**:
1. Write a vulnerable C program with a buffer overflow
2. Compile it
3. Open it in Binary Ninja
4. Identify the buffer overflow vulnerability
5. Document your findings

**Verification**: You should be able to identify the buffer overflow.

### Exercise 2: Identify Format String Vulnerabilities

**Objective**: Learn to recognize format string vulnerabilities.

**Steps**:
1. Write a vulnerable C program with a format string vulnerability
2. Compile it
3. Open it in Binary Ninja
4. Identify the format string vulnerability
5. Document your findings

**Verification**: You should be able to identify the format string vulnerability.

### Exercise 3: Identify Use-After-Free Bugs

**Objective**: Learn to recognize use-after-free bugs.

**Steps**:
1. Write a vulnerable C program with a use-after-free bug
2. Compile it
3. Open it in Binary Ninja
4. Identify the use-after-free bug
5. Document your findings

**Verification**: You should be able to identify the use-after-free bug.

## Solutions

### Solution 1: Identify Buffer Overflow Vulnerabilities

When you analyze a buffer overflow, you should see:
- A buffer allocated on the stack
- A `strcpy` or similar unsafe function
- No bounds checking

### Solution 2: Identify Format String Vulnerabilities

When you analyze a format string vulnerability, you should see:
- User input passed to `printf` or similar
- No validation of the format string

### Solution 3: Identify Use-After-Free Bugs

When you analyze a use-after-free bug, you should see:
- A `free` call
- Followed by a dereference of the freed pointer

## Summary

You now understand common vulnerability patterns. You can:

- Recognize buffer overflows
- Recognize format string vulnerabilities
- Recognize use-after-free bugs
- Recognize integer overflows
- Identify these vulnerabilities in disassembly

In the next lesson, you'll learn about malware analysis.
